<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="nico" />
  <meta name="author" content="Pierre-Yves Rochat, EPFL" />
  <title>Rubans de LED</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../statiques/style.css" type="text/css" />
</head>
<body>
<h1 class="title">Rubans de LED</h1>
<div id="header">
<p class="author"><a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#112;&#x79;&#114;&#64;&#112;&#x79;&#114;&#46;&#x63;&#104;" class="email">&#80;&#x69;&#x65;&#114;&#114;&#x65;&#x2d;&#x59;&#118;&#x65;&#x73;&#32;&#82;&#x6f;&#x63;&#104;&#x61;&#116;</a>, EPFL</p>
<p class="date">rév 2016/07/17</p>
</div>
<p>Document incomplet, en cours de rédaction.</p>
<h2 id="plusieurs-sortes-de-rubans-de-led">Plusieurs sortes de rubans de LED</h2>
<p>Les rubans de LED, en anglais <em>LED strips</em>, sont des LED disposées en ligne. Elles sont reliées entre elles par un circuit imprimé flexible, ou simplement par des fils. On trouve sur le marché plusieurs types de rubans de LED. On distingue principalement les rubans uniformes et les rubans adressables. Les rubans uniformes peuvent être d'une seule couleur fixe. Dans ce cas seule l'intensité peut être modifiée, pour toutes les LED du ruban en même tems, par une commande en PWM. Les rubans peuvent aussi être multicolores (RGB). Dans ce cas, tout le ruban peut changer de couleur en même temps. La commande se fait par un triple PWM, un pour chaque couleur.</p>
<p>Basés sur une technologie très différente, il existe aussi des rubans adressables (<em>addressable led strips</em>). Chaque pixel du ruban peut alors prendre une couleur indépendamment des autres pixels.</p>
<h2 id="les-rubans-uniformes">Les rubans uniformes</h2>
<p>Les rubans uniformes ne contiennent que des LED avec leurs résistances de limitation. Généralement, l'alimentation est de 12 V, ce qui signifie que plusieurs LED sont mises en série. Pour des rubans RGB, le câblage est généralement à cathod commune, avec une connexion pour les cathodes et trois connexions pour les anodes des LED rouges, vertes et bleues :</p>
<div class="figure">
<img src="images/archi-uniforme.svg" title="Rubans uniformes" alt="Rubans uniformes" style="width:90.0%" />
<p class="caption">Rubans uniformes</p>
</div>
<h2 id="les-rubans-adressables">Les rubans adressables</h2>
<p>Plusieurs solutions sont techniquement possibles pour faire varier l'intensité de chaque pixel d'un ruban. Celles qui minimisent le nombre de fils utilisé sont évidemment les plus intéressantes. Il faut forcément deux fils pour alimenter les LED, le <em>Gnd</em> et le <em>Vcc</em>. Est-ce possible d'utiliser un seul fil pour apporter à chaque pixel l'information qui le concerne ?</p>
<p>Une solution très souvent utilisée présente l'architecture suivante :</p>
<div class="figure">
<img src="images/archi-adressable.svg" title="Rubans adressables à 3 fils" alt="Rubans adressables à 3 fils" style="width:90.0%" />
<p class="caption">Rubans adressables à 3 fils</p>
</div>
<p>Alors que les deux fils d'alimentation relient chaque module de pixel, le troisième fil relie la sortie d'un module vers l'entrée d'un autre.</p>
<h2 id="le-protocole-des-ws28xx">Le protocole des WS28xx</h2>
<p>On imagine bien que les données vont être transmises en série. Mais il devient nécessaire de regrouper sur un seul fil les données et l'horloge. Le principe est une horloge asymétrique :</p>
<div class="figure">
<img src="images/horloge-asym.svg" title="Horloge asymétrique" alt="Horloge asymétrique" style="width:75.0%" />
<p class="caption">Horloge asymétrique</p>
</div>
<p>Chaque bit est transmis par un cycle d'horloge. Lorsque la durée de la partie haute du signal est plus longue que le durée de la partie basse, le bit transmis est un zéro.</p>
<p>Dans le cas des circuits de la famille WS28xx, un circuit intégré est utilisé pour chaque pixel, composé de trois LED de couleur rouge, verte et bleu. Souvent, les trois LED sont encapsulées dans le même boîtier. On parle alors d'une LED RGB (<em>Red Green Blue</em>).</p>
<p>Chaque LED est commandée par un signal PWM de 8 bits. Il est donc nécessaire d'envoyer 24 bits pour chaque pixel.</p>
<p>Pour synchroniser le début de l'envoi d'une nouvelle série de valeurs à tous les pixels du ruban, une attente d'au moins 50 us est nécessaire. Chaque circuit est alors prêt à recevoir 24 bits. L'astuce utilisée est alors la suivante : chaque circuit ne transmet à sa sortie les information qui se présentent à sont entrée qu'après avoir enregistré les 24 premiers bits qui succèdent au Reset.</p>
<p>La figure suivante explique ce principe :</p>
<div class="figure">
<img src="images/horloge-asym.svg" title="Mise en cascade des modules" alt="Mise en cascade des modules" style="width:90.0%" />
<p class="caption">Mise en cascade des modules</p>
</div>
<h2 id="signaux-rapides">Signaux rapides</h2>
<p>Les contraintes qu'imposent ce circuit sur le timing des signaux rendent difficile sa programmation avec un AVR ou un MSP430. Des solutions ont toutefois été trouvées, en programmant en assembleur ou encore en utilisant de manière astucieuse le circuit de communication série.</p>
<p>Avec un processeur ARM, c'est plus facile de respecter les exigence temporelles. Nous allons ici montrer un programme écrit pour un STM32, testé sur une carte Nucleo. Voici la partie avec les définitions :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Signal One Wire pour WS2811 :</span>
<span class="ot">#define WS2811_Pin GPIO_PIN_10</span>
<span class="ot">#define PORT_WS2811 GPIOA</span>
<span class="ot">#define BIT_WS2811 10</span>
<span class="ot">#define WS28On (PORT_WS2811-&gt;ODR|=(1&lt;&lt;BIT_WS2811))</span>
<span class="ot">#define WS28Off (PORT_WS2811-&gt;ODR&amp;=~(1&lt;&lt;BIT_WS2811))</span>

<span class="dt">void</span> SystemClock_Config(<span class="dt">void</span>);
<span class="dt">static</span> <span class="dt">void</span> MX_GPIO_Init(<span class="dt">void</span>);

<span class="ot">#define Un WS28On;WS28On;WS28On;WS28On;WS28On;WS28On;WS28On;WS28Off;</span>
<span class="ot">#define Zero WS28On;WS28Off;WS28Off;WS28Off;WS28Off;WS28Off;WS28Off;WS28Off</span>

<span class="ot">#define UnCourt WS28On;WS28On;WS28On;WS28On;WS28On;WS28On;WS28Off;</span>
<span class="ot">#define ZeroCourt WS28On;WS28Off;WS28Off;WS28Off;WS28Off;WS28Off;WS28Off;</span>


<span class="co">// Contenu du ruban :</span>
<span class="ot">#define LgRuban 50</span>
<span class="dt">uint32_t</span> Ruban[LgRuban];</code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(<span class="dt">void</span>) { <span class="co">// Programme principal :</span>
  HAL_Init(); <span class="co">// Initialisation de la librairie Hardware Level</span>
  SystemClock_Config(); <span class="co">// Configure l&#39;horloge système</span>
  MX_GPIO_Init(); <span class="co">// Initialise les périphériques</span>

  PORT_WS2811-&gt;MODER |= (<span class="bn">0b01</span> &lt;&lt; (BIT_WS2811*<span class="dv">2</span>)); <span class="co">// broche en sortie</span>

  <span class="dt">uint32_t</span> i;
  <span class="dt">volatile</span> <span class="dt">uint16_t</span> j;
  <span class="dt">uint32_t</span> v;
  <span class="dt">uint32_t</span> idx;
  <span class="dt">uint32_t</span> *pt; <span class="co">// pointeur</span>

  <span class="co">// Initialisations fixes des couleurs</span>
  <span class="kw">for</span> (idx=<span class="dv">0</span>; idx&lt;LgRuban; idx++) {
    Ruban[idx] = <span class="dv">1</span>&lt;&lt;idx;
  }

  <span class="kw">while</span> (<span class="dv">1</span>) { <span class="co">// boucle principale</span>
    pt = Ruban;
    __ASM <span class="dt">volatile</span> (<span class="st">&quot;cpsid i&quot;</span>);

    <span class="kw">for</span> (idx=<span class="dv">0</span>; idx&lt;LgRuban; idx++) {
      v = *pt;
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">23</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">22</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">21</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">20</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">19</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">18</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">17</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">16</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">15</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">14</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">13</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">12</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">11</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">10</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">9</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">8</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">7</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">6</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">5</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">4</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">3</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>)) {Un;} <span class="kw">else</span> {Zero;}
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">1</span>)) {UnCourt;} <span class="kw">else</span> {ZeroCourt;}
      pt++;
      <span class="kw">if</span> (v &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">0</span>)) {UnCourt;} <span class="kw">else</span> {ZeroCourt;}
    }

    __ASM <span class="dt">volatile</span> (<span class="st">&quot;cpsie i&quot;</span>);

    <span class="kw">for</span> (j=<span class="dv">0</span>; j&lt;<span class="dv">500</span>; j++) {
    }
  }
}</code></pre></div>
<p>Il est alors possible de créer des animations sur les LED. Une variable <code>temps</code> va compter le temps qui s'écoule et comptant les cycles de raffraîchissement du ruban. En fonction du temps, les couleurs des LED peuvent être modifiées :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    temps++; <span class="co">// comptage du temps</span>

    <span class="co">// Clignotement des la LED 0 et 30 :</span>
    <span class="kw">if</span> (temps==<span class="dv">500</span>) {
        Ruban[<span class="dv">30</span>] = Ruban[<span class="dv">0</span>] = <span class="bn">0xFFFFFF</span>;
    }
    <span class="kw">if</span> (temps==<span class="dv">1000</span>) {
        temps=<span class="dv">0</span>; Ruban[<span class="dv">30</span>] = Ruban[<span class="dv">0</span>] = <span class="dv">0</span>;
    }
    <span class="co">// Chamgement progressif de la couleur de le LED 47 :</span>
    Ruban[<span class="dv">47</span>]++;</code></pre></div>
<!-- retour au mode normal pour l'éditeur -->
</body>
</html>