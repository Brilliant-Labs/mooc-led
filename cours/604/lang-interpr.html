<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="nico" />
  <meta name="author" content="Pierre-Yves Rochat, EPFL" />
  <title>Langage interprété spécialisé</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../statiques/style.css" type="text/css" />
</head>
<body>
<h1 class="title">Langage interprété spécialisé</h1>
<div id="header">
<p class="author"><a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#112;&#x79;&#114;&#64;&#112;&#x79;&#114;&#46;&#x63;&#104;" class="email">&#80;&#x69;&#x65;&#114;&#114;&#x65;&#x2d;&#x59;&#118;&#x65;&#x73;&#32;&#82;&#x6f;&#x63;&#104;&#x61;&#116;</a>, EPFL</p>
<p class="date">rév 2016/01/22</p>
</div>
<h2 id="motivation">Motivation</h2>
<p>Animer une enseigne à LED consiste en une suite d’opérations sur les groupes LED. Animer un afficheur matriciel consiste aussi à envoyer des séquences graphiques. Dans les deux cas, une jolie animation ne se limitera pas à quelques étapes, mais pourra vite devenir longue. Les programmes correspondant vont donc avoir tendance à devenir longs, ce qui va rendre leur lecture fastidieuse et qui risque aussi de remplir rapidement la mémoire du microcontrôleur.</p>
<p>Une technique souvent utilisée consiste à <strong>inventer</strong> un <em>langage</em> pour décrire ce qui se passe sur l’enseigne ou l’afficheur et programmer les animations dans ce langage.</p>
<h2 id="langage-arduino">Langage Arduino</h2>
<p>Prenons l’exemple très simple. Pour décrire une animation sur une enseigne, deux ordres suffisent pour décrire les actions :</p>
<ul>
<li>mettre un groupe de LED à une certaine intensité</li>
<li>attendre un certain temps.</li>
</ul>
<p>Dans le cas simple de sorties tout-ou-rien, voici les procédures Arduino qui vont suffire :</p>
<ul>
<li>digitalWrite() de l’Arduino convient pour donner un état à une sortie</li>
<li>delay() pour une attente.</li>
</ul>
<p>En observant la taille d’un petit programme sur Energia et en ajoutant des appels à ces procédures, on constate que :</p>
<ul>
<li>digitalWrite() prend 8 octets en mémoire</li>
<li>delay() prend 10 octets en mémoire.</li>
</ul>
<p>En prenant par exemple un microcontrôleur MSP430G2213, disposant d’une mémoire flash de 2kB (2048 octets), on sera limité à moins de 80 pas de programme, constitué de paires digitalWrite() - delay(). En constatant qu’un simple chenillard dans les deux sens sur 8 bits en prend déjà 16, c’est réellement limitatif !</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="sourceCode"><pre><code class="sourceCode c">loop() {
  digitalWrite (P2_0, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_1, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_2, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_3, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_4, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_5, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_6, <span class="dv">1</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_7, <span class="dv">1</span>); delay (<span class="dv">200</span>);
  digitalWrite (P2_7, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_6, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_5, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_4, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_3, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_2, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_1, <span class="dv">0</span>); delay (<span class="dv">100</span>);
  digitalWrite (P2_0, <span class="dv">0</span>); delay (<span class="dv">300</span>);
}</code></pre></td></tr></table></div>
<!-- retour au mode normal -->
<p>Bien entendu, les instructions permettant l’accès direct aux registres du microcontrôleur permettent d’économiser la place en mémoire. L’instruction P1OUT |= (1&lt;&lt;0); &lt;--- --- &gt; prend 4 octets. C’est déja mieux ! Mais cherchons une autre solution.</p>
<h2 id="inventer-un-langage">Inventer un langage</h2>
<p>Une solution élégante est d’inventer un langage. Il aura les deux même instructions :</p>
<ul>
<li><strong>Mettre une intensité sur une sortie</strong>. Paramètres : numéro de la sorte et intensité (0 ou 1)</li>
<li><strong>Attendre</strong>. Paramètre : durée de l’attente</li>
</ul>
<p>Le programme pourrait alors se présenter sous forme d’un tableau. Nous avons utilisé ici un tableau d’octets. Le programme pour notre chenillard se présenterai alors de la manière suivante :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">uint8_t</span> Animation[] = { <span class="co">// définition d&#39;un tableau d&#39;octets</span>
  Sortie0+On, Attente<span class="dv">+10</span>,
  Sortie1+On, Attente<span class="dv">+10</span>,
  Sortie2+On, Attente<span class="dv">+10</span>,
  Sortie3+On, Attente<span class="dv">+10</span>,
  Sortie4+On, Attente<span class="dv">+10</span>,
  Sortie5+On, Attente<span class="dv">+10</span>,
  Sortie6+On, Attente<span class="dv">+10</span>,
  Sortie7+On, Attente<span class="dv">+20</span>,
  Sortie7+Off, Attente<span class="dv">+10</span>,
  Sortie6+Off, Attente<span class="dv">+10</span>,
  Sortie5+Off, Attente<span class="dv">+10</span>,
  Sortie4+Off, Attente<span class="dv">+10</span>,
  Sortie3+Off, Attente<span class="dv">+10</span>,
  Sortie2+Off, Attente<span class="dv">+10</span>,
  Sortie1+Off, Attente<span class="dv">+10</span>,
  Sortie0+Off, Attente<span class="dv">+30</span>,
  Fin
}</code></pre></td></tr></table></div>
<!-- retour au mode normal -->
<p>Sa taille n’est que de 33 octets. Voici les définitions nécessaire pour que ce tableau se compile correctement :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#define On 0b01000000</span>
<span class="ot">#define Sortie0 0</span>
<span class="ot">#define Sortie1 1</span>
<span class="ot">#define Sortie2 2</span>
<span class="ot">#define Sortie3 3</span>
<span class="ot">#define Sortie4 4</span>
<span class="ot">#define Sortie5 5</span>
<span class="ot">#define Sortie6 6</span>
<span class="ot">#define Sortie7 7</span>

<span class="ot">#define Attente 0b10000000</span>
<span class="ot">#define Fin 0b1111111</span></code></pre></td></tr></table></div>
<!-- retour au mode normal -->
<h2 id="langage-binaire">Langage binaire</h2>
<p>Voici la description binaire de notre langage :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">// Description des instructions :</span>
<span class="co">// b7 b6 b5 b4 b3 b2 b1 b0  : instructions sur 8 bits</span>
<span class="co">// -----------------------</span>
<span class="co">//  0 i0 s5-s4-s3-s2-s1-s0  : met une intensité sur une sortie</span>
<span class="co">//  1 d6-d5-d4-d3-d2-d1-d0  : attente</span>
<span class="co">// -----------------------</span>
<span class="co">//</span>
<span class="co">// Sorties sur 6 bits (maximum 64 sorties)</span>
<span class="co">// Intensité sur 1 bit (On ou OFF)</span>
<span class="co">// Durée sur 7 bits, exprimée en dixième de seconde (0 à 12.6 secondes)</span></code></pre></td></tr></table></div>
<!-- retour au mode normal -->
<p>Ceux qui ont déjà programmé en assembleur trouveront une grande similitude avec la description des instruction en binaire !</p>
<p>On voit que des choix ont été faits pour utiliser au mieux les instructions, qui sont des champs de 8 bits. Le bit de poids fort b7 détermine s’il s’agit d’une instruction pour définir l’intensité ou pour l’attente. Ensuite, les 7 bits restant se répartissent selon l’instruction : une intensité et un numéro de sortie pour l’action sur une sortie, une valeur en dixième de seconde pour l’attente. L’usage de la milliseconde comme unité aurait été trop limitative, étant donné que seuls 7 bits sont à disposition.</p>
<h2 id="interpréteur">Interpréteur</h2>
<p>Il reste à écrire une procédure qui va interpréter notre langage et le traduire en instructions pour un microcontrôleur. En voici un exemple :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre></pre></td><td class="sourceCode"><pre><code class="sourceCode c"></code></pre></td></tr></table></div>
<!-- retour au mode normal -->
<h2 id="exemple-plus-complexe">Exemple plus complexe</h2>
</body>
</html>