<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Pierre-Yves Rochat, EPFL" />
  <title>Afficheurs matriciels</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../statiques/style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Afficheurs matriciels</h1>
<h2 class="author"><a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#112;&#x79;&#114;&#64;&#112;&#x79;&#114;&#46;&#x63;&#104;" class="email">&#80;&#x69;&#x65;&#114;&#114;&#x65;&#x2d;&#x59;&#118;&#x65;&#x73;&#32;&#82;&#x6f;&#x63;&#104;&#x61;&#116;</a>, EPFL</h2>
<h3 class="date">rév 2015/09/16</h3>
</div>
<h2 id="afficheurs-et-écrans">Afficheurs et écrans</h2>
<!--
Comme les afficheurs sont le sujet de ce MOOC, je me demande si tu ne devrais pas prévoir un chapitre d’introduction où tu décris de manière très générale les types d’affichages existants et où tu précises les types qui seront abordés dans le cours et ceux qui ne le seront pas. Peut-être que tu avais prévu de le faire, mais ça ne se voit pas dans la table des matières.
PYR : c’est ce sujet qui devrait introduire le concept d’afficheur, par opposition aux enseignes, généralement fixes. Le problème se posera en anglais : je n’ai pas trouvé de bonne traduction pour "enseignes et afficheurs".
-->
<p>Voici une définition du mot afficheur : dispositif électronique permettant de présenter visuellement des données. Cette définition correspond aussi très bien à ce qu’on appelle un écran. Ce terme “écran” vient de la technique des tubes cathodiques, qui comportaient un écran de phosphore, capable de transformer le faisceau d’électrons en une tache lumineuse.</p>
<p>Depuis plusieurs décennies, les LCD (<em>Liquid Cristal Display</em>) dominent ce domaine, tant pour de petits afficheurs que pour des écrans de taille respectable. On parle parfois, par abus de langage, d’écrans à LED pour désigner des écrans LCD rétroéclairés par des LED. Il ne faut pas les confondre avec les écrans à O-LED (LED organiques), qui prennent des parts de marché de plus en plus importantes.</p>
<p>Ces domaines ne sont pas le sujet de notre cours. Nous allons nous concentrer sur les dispositifs réalisés avec des LED indépendantes.</p>
<h2 id="notion-de-pixel">Notion de pixel</h2>
<p>Chaque point d’un afficheur ou d’un écran est appelé un <em>pixel</em>. Il peut être d’une seule couleur (monochrome) ou capable de prendre plusieurs couleurs (polychrome ou multicolore). Dans le cadre de ce cours, les mots <em>points</em> et <em>pixels</em> sont synonymes et utilisés indifféremment. <em>Pixel</em> est un mot-valise formé par la fusion des mots de la locution anglaise <em>picture element</em> ou <em>élément d’image</em> en français.</p>
<p>Un afficheur est caractérisé par plusieurs paramètres, dont un des plus importants est le nombre de pixels qu’on indique souvent sous la forme de deux paramètres : le nombre de lignes et le nombre de points par lignes.</p>
<p>Dans le domaine des écrans, les modèles VGA des années 1980 affichaient 480 lignes de 640 points. Aujourd’hui, l’écran d’un ordinateur portable à faible coût peut afficher 800 lignes de 1’280 pixels. Une image vidéo <em>Full HD</em> affiche 1’080 lignes de 1’920 pixels.</p>
<p>La taille de l’afficheur est évidemment aussi un paramètre important, sa <em>hauteur</em> (on part de l’idée que l’écran est vertical <!-- Quelle importance ? C’est la même chose que l’écran soit horizontal ou vertical. PYR: on devrait dire longeur et largeur. Je ne parle pas de Portrait ou Paysage, mais bien de Vertical ou Honrizontal -->) et sa <em>largeur</em>.</p>
<p>À partir de la taille et du nombre de pixels, on peut calculer deux autres caractéristiques d’un afficheur :</p>
<ul>
<li>Sa <em>résolution</em> : C’est la distance entre un pixel et son plus proche voisin. On l’exprime généralement en millimètre. Les fabricants donnent souvent une expression comme P6 ou P10. La lettre P vient du mot <em>Pitch</em> (le pas). Il s’agit de la distance entre chaque pixel exprimée en millimètre (mm).</li>
<li>Sa <em>densité</em> : C’est le nombre de pixels par unité de surface. L’unité est généralement exprimée en pixels par mètre carrés (px/m²).</li>
</ul>
<p>Prenons l’exemple d’un afficheur P6. La distance entre chaque pixel est de 6 mm. On peut donc aligner environ 167 LED sur un mètre. Il faut donc plus de 27’800 LED pour remplir un mètre carré ! En l’absence d’indication contraire, on considère que les résolutions horizontales et verticales sont identiques.</p>
<h2 id="afficheurs-à-led">Afficheurs à LED</h2>
<p>Un afficheur à LED est donc un ensemble de LED dont il est possible de choisir l’état de chacune d’elles indépendamment des autres.</p>
<p>Les LED sont généralement disposées en lignes et en colonnes : on obtient un afficheur orthogonal.</p>
<div class="figure">
<img src="images/aff-10x24-120dpi.png" title="Afficheur de 10x24 LED" alt="Afficheur de 10x24 LED" width="491" />
<p class="caption">Afficheur de 10x24 LED</p>
</div>
<p>Si la distance est la même horizontalement et verticalement (en x et y), l’afficheur est orthonormé. La géométrie des LED permet de réaliser toutes sortes d’afficheurs, sans se limiter à une grille orthonormée. Il existe des afficheurs cylindriques, sphériques ou en forme de pyramide ! Plus couramment, on trouve des afficheurs qui prennent une forme dont la signification est connue, comme les afficheurs en forme de croix de pharmacie, très répandus depuis quelques années.</p>
<p>La taille des afficheurs à LED varie de manière considérable : on trouve de petits journaux lumineux intégrés à des médaillons de ceinture, mais il existe aussi des afficheurs vidéos d’une surface de plusieurs dizaines de mètres carrés.</p>
<p>Chaque pixel peut être composé d’une LE. Il existe aussi des afficheurs comportant deux LED par pixel, généralement verte et rouge. Il s’agit d’un héritage historique, de l’époque où les LED bleues n’étaient pas disponibles ou hors de prix. Il faut noter que la composition du rouge et du vert donne une couleur ressemblant à l’orange. Finalement, beaucoup d’afficheurs à LED comportent trois LED, rouge, verte et bleue. Il est alors possible d’obtenir toutes les autres couleurs par composition.</p>
<h2 id="commande-des-led-par-des-registres">Commande des LED par des registres</h2>
<p>Le nombre important de LED d’un afficheur matriciel, même de petite taille, ne permet généralement pas une commande de chaque LED par une broche d’un microcontrôleur. C’est seulement le cas pour de petits afficheurs commandés par <em>multiplexage temporel</em>, sujet qui sera abordé plus tard dans ce cours. Dans tous les autres cas, des registres sont utilisés pour commander les LED.</p>
<p>Prenons comme exemple l’afficheur de 8 lignes de 16 LED dont le schéma est indiqué sur la figure ci-dessous. Chacune de ses lignes utilise un registre série-parallèle de 16 bits, il y a donc 8 registres. Les registres séries sont indiqués avec une flèche pointant vers la droite. Les registres parallèles sont indiqués avec une flèche pointant vers le haut. Les entrées des horloges des registres sont indiquées par des triangles.</p>
<p>Les horloges des registres séries sont toutes connectées à la broche P1.4, ce qui implique que les données sont chargées en même temps sur tous ces registres. À chaque coup d’horloge, la valeur présentée à l’entrée est décalée dans le registre. Sur la figure, les valeurs d’entrée sont données par les broches P2.0, P2.1...P2.7.</p>
<p>Une fois les 16 valeurs introduites dans les registres séries, elles sont transférées aux registres parallèles dont les horloges sont toutes connectées à la broche P1.5 du microcontrôleur. Les valeurs ainsi chargées dans les registres parallèles sont immédiatement affichées sur les LED.</p>
<!--
Sur le schéma, pour les 3 registres, la 5e LED depuis la gauche est cul-de-jatte.
Je corrige...
-->
<div class="figure">
<img src="images/aff-8x16-120dpi.png" title="Schéma d’un afficheur comportant 8 lignes de 16 LED" alt="Schéma d’un afficheur comportant 8 lignes de 16 LED" width="529" />
<p class="caption">Schéma d’un afficheur comportant 8 lignes de 16 LED</p>
</div>
<p>Remarquez que les LED n’ont pas de résistances série. Les registres utilisés contiennent des sources de courant ajustables au moyen d’une seule résistance pour tout le registre.</p>
<h2 id="programmation">Programmation</h2>
<p>Comment écrire le programme qui contrôle ce montage ? On souhaite par exemple faire défiler un texte, pour afficher un journal lumineux. La première idée qui vient à l’esprit est d’utiliser les propriétés du registre pour introduire successivement les colonnes de pixels qui forment chaque caractère. Voici un programme qui pourrait fonctionner. Il se limite pour le moment à envoyer un motif en <em>dents de scie</em> :</p>
<!--
Dans tes programmes, tu utilises des noms comme “SerClockOn” et “SerClockOff”. Le problème avec ce cette façon de faire, c’est qu’on doit réfléchir pour déterminer si tu veux faire une lecture (est-ce que la valeur est ON ?) ou une écriture (mettre la valeur à ON).

Comme ce problème est un classique, la plupart des langages de programmation utilisent les conventions suivantes :

Pour l’écriture : SET, CLEAR, TOGGLE

Pour la lecture : GET

Je pense donc que tes codes seraient plus clairs si tu faisais les remplacements suivants :

SerClockOn ⇒ SerClockSet
SerClockOff ⇒ SerClockClear

Ce problème m’avait donné pas mal de fil à retordre lors du MOOC µcontrôleurs.

==> JUSTE ! Mais il faudra traquer les incohérences dans d’autres leçons !

-->
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">int</span> main() {
  init(); <span class="co">// initialisations...</span>
  <span class="dt">uint8_t</span> i;
  <span class="kw">while</span> (<span class="dv">1</span>) {
    <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">16</span>; i++) { <span class="co">// envoie une colonne avec un seul pixel allumé</span>
      P1OUT = (<span class="dv">1</span>&lt;&lt;(i&amp;<span class="dv">7</span>)); <span class="co">// 1 col de 8 px, 1 seul allumé -&gt; dents de scie</span>
      SerClockOn; SerClockClear; <span class="co">// envoie un coup d&#39;horloge série</span>
      ParCloclOn; ParClockClear; <span class="co">// envoie un coup d&#39;horloge</span>
    }
  }
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Pour générer des caractères, il faut disposer d’une table décrivant les positions des pixels des différents caractères. Voici une manière de les représenter :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">const</span> <span class="dt">uint8_t</span> GenCar [] { <span class="co">// tableau des pixels des caractères</span>
  <span class="bn">0b01111110</span>, <span class="co">// caractère &#39;A&#39;</span>
  <span class="bn">0b00001001</span>, <span class="co">// Il faut pencher la tête à droite</span>
  <span class="bn">0b00001001</span>, <span class="co">// pour voir sa forme !</span>
  <span class="bn">0b00001001</span>,
  <span class="bn">0b01111110</span>,

  <span class="bn">0b01111111</span>, <span class="co">// caractère &#39;B&#39;</span>
  <span class="bn">0b01001001</span>, <span class="co">// Les caractères forment</span>
  <span class="bn">0b01001001</span>, <span class="co">// une matrice de 5x7</span>
  <span class="bn">0b01001001</span>,
  <span class="bn">0b00110110</span>,

  <span class="bn">0b00111110</span>, <span class="co">// caractère &#39;C&#39;</span>
  <span class="bn">0b01000001</span>, <span class="co">// Les caractères ont ici</span>
  <span class="bn">0b01000001</span>, <span class="co">// une chasse fixe, c&#39;est-à-dire</span>
  <span class="bn">0b01000001</span>, <span class="co">// que tous les caractères ont</span>
  <span class="bn">0b01000001</span>  <span class="co">// la même largeur en pixels</span>
};</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Voici un programme qui affiche un texte : <!-- Est-ce que tu expliques le concept de pointeur dans le cours ? PYR : Pas prévu... à réfléchir ! --></p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">const</span> <span class="dt">char</span> *Texte = <span class="st">&quot;ABC\0&quot;</span>; <span class="co">// texte, terminé par le caractère nul</span>
<span class="dt">char</span> *ptTexte; <span class="co">// pointeur vers le texte à afficher</span>

<span class="dt">int</span> main(<span class="dt">void</span>) {
  init(); <span class="co">// initialisations...</span>
  <span class="kw">while</span>(<span class="dv">1</span>) { <span class="co">// le texte défile sans fin</span>
    ptTexte = Texte;
    <span class="kw">while</span> (*ptTexte!=&#39;\<span class="dv">0</span>&#39;) { <span class="co">// boucle des caractères du texte</span>
      caractere = *ptTexte; <span class="co">// le caractère à afficher</span>
      idxGenCar = (caractere-&#39;A&#39;) * <span class="dv">5</span>; <span class="co">// conversion ASCII à index GenCar[]</span>
      <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;<span class="dv">5</span>; i++) { <span class="co">// envoie les 5 colonnes du caractère</span>
        P2OUT = ~GenCar[idxGenCar++]; <span class="co">// 1 colonne du caractère (actif à 0)</span>
        SerClockSet; SerClockClear; <span class="co">// coup d&#39;horloge série</span>
        ParClockSet; ParClockClear; <span class="co">// coup d&#39;horloge parallèle</span>
        AttenteMs (delai);
      }
      ptTexte++; <span class="co">// passe au caractère suivant</span>
      P2OUT = ~<span class="dv">0</span>; <span class="co">// colonne vide, séparant les caractères</span>
      SerClockSet; SerClockClear; <span class="co">// coup d&#39;horloge série</span>
      ParClockSet; ParClockClear; <span class="co">// coup d&#39;horloge parallèle</span>
      AttenteMs (delai);
    }
  }
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Dans l’exemple ci-dessus, le texte à afficher est enregistré dans un tableau. L’instruction <code>const</code> indique au compilateur que ce tableau peut être stocké en mémoire de programme. Sans cette instruction, il aurait été enregistré en mémoire RAM qui est souvent nettement plus petite que la mémoire de programme. Pour accéder aux caractères de ce texte, un pointeur est utilisé. La déclaration du pointeur s’écrit : <code>const char *ptTexte;</code>. Le symbole * indique qu’il s’agit d’un pointeur.</p>
<p>Cette manière d’envoyer les caractères fonctionne, mais présente tellement de limitations qu’elle ne sera jamais utilisée. Par exemple, elle ne peut pas fonctionner si l’ordre des LED est inversé : le texte ne pourra pas être décalé correctement de droite à gauche. Elle est aussi incompatible avec les afficheurs multiplexés.</p>
<h2 id="génération-et-rafraîchissement-séparés">Génération et rafraîchissement séparés</h2>
<p>La bonne manière de programmer un afficheur est de <strong>séparer</strong> complètement la génération de l’image à afficher et l’envoi de cette image sur l’afficheur. La valeur courante de chaque pixel est placée dans une <strong>mémoire</strong>. La partie du logiciel qui prépare les images <strong>écrit</strong> dans cette mémoire. Les procédures qui envoient les informations à l’afficheur <strong>lisent</strong> dans cette mémoire.</p>
<p>Dans notre exemple, l’afficheur a 8 lignes de 16 pixels. Un mot de 16 bits pourra donc stocker une ligne. Voici comment réserver la zone mémoire pour les pixels :</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define NbLignes 8</span>
<span class="dt">uint16_t</span> Matrice[NbLignes]; <span class="co">// mots de 16 bits, correspondant à une ligne</span></code></pre></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Nous choissons de placer les axes x et y de la manière suivante :</p>
<div class="figure">
<img src="images/organisation-aff-8x16-120dpi.png" title="Organisation de l’afficheur 8x16 pixels" alt="Organisation de l’afficheur 8x16 pixels" width="415" />
<p class="caption">Organisation de l’afficheur 8x16 pixels</p>
</div>
<p>Les procédures permettant d’allumer et d’éteindre un pixel, désigné par ses coordonnées, sont particulièrement simples dans ce cas :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">void</span> AllumePoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[y] |= (<span class="dv">1</span>&lt;&lt;x); <span class="co">// set bit</span>
}

<span class="dt">void</span> EteintPoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[y] &amp;=~(<span class="dv">1</span>&lt;&lt;x); <span class="co">// clear bit</span>
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Voici une procédure pour afficher une diagonale en travers de l’afficheur :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#define MaxX 16</span>
<span class="ot">#define MaxY NbLignes</span>

<span class="dt">void</span> Diagonale() {
  <span class="dt">int16_t</span> i;
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;MaxY; i++) {
    AllumePoint(i*MaxX/MaxY, i);
  }
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Mais toutes ces procédures ne vont rien afficher sur les LED ! Il faut encore une procédure qui va placer chaque pixel sur la LED correspondante. Pour l’écrire, il faut garder en mémoire l’organisation matérielle de notre matrice, avec les 8 registres série-parallèles de 16 bits.</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    <span class="co">// Préparation des valeurs qui doivent être envoyées aux 8 registres:</span>
    <span class="kw">for</span> (<span class="dt">uint16_t</span> y=<span class="dv">0</span>; y&lt;MaxY; y++)  {
      <span class="kw">if</span> (Matrice[y]&amp;(<span class="dv">1</span>&lt;&lt;x)) P2OUT &amp;=~(<span class="dv">1</span>&lt;&lt;y); <span class="kw">else</span> P2OUT |= (<span class="dv">1</span>&lt;&lt;y);
    }
    SerClockSet; SerClockClear; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockSet; ParClockClear; <span class="co">// envoie les valeur sur les LED</span>
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Cette procédure semble compliquée. Une organisation optimisée des données en mémoire pourrait la simplifier :</p>
<div class="figure">
<img src="images/organisation-aff-8x16-byte-120dpi.png" title="Organisation plus optimale des pixels en mémoire" alt="Organisation plus optimale des pixels en mémoire" width="340" />
<p class="caption">Organisation plus optimale des pixels en mémoire</p>
</div>
<p>Voici la définition et la procédure correspondante :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#define NbColonnes 16</span>
<span class="dt">uint8_t</span> Matrice[NbColonnes]; <span class="co">// mots de 8 bits, correspondant à une colonne</span>

<span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    P2OUT = ~Matrice[x];
    SerClockSet; SerClockClear; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockSet; ParClockClear; <span class="co">// envoie les valeur sur les LED</span>
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>Non seulement la procédure <code>AfficheMatrice()</code> est beaucoup plus simple, mais en plus elle va prendre moins de temps à être exécutée. Dans notre cas, la vitesse ne pose pas de problème. Mais dès que les afficheurs deviennent plus grands, cette question devient cruciale.</p>
<p>De manière générale, on va donc chercher à optimiser l’organisation des pixels en mémoire en vue de simplifier et de rendre plus rapide l’envoi des pixels sur les LED, quitte à compliquer un peu les procédures qui créent les images. <!-- Je ne comprends pas pourquoi on devrait créer des images puisque au contraire on les stocke en mémoire... PYR On part d’une description vectorielle (points, segments) et on crèe des images bitmap, qui sont ensuite affichées --></p>
<h2 id="programmer-des-animations">Programmer des animations</h2>
<p>Pour générer des animations sur l’afficheur, il faut :</p>
<ul>
<li>préparer une image en mémoire,</li>
<li>envoyer son contenu sur l’afficheur,</li>
<li>attendre le temps nécessaire,</li>
<li>préparer une autre image <!-- C’est le premier point ⇒ donc tu peux enlever celui-ci. PYR Le mot autre aide à comptendre, je préfère laisser la répétition --></li>
</ul>
<p>et ainsi de suite.</p>
<p>Voici un programme complet qui génère une animation graphique sur notre afficheur :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">// Afficheur didactique 16x8</span>
<span class="co">// Les 8 bits sont sur P2</span>
<span class="co">// Usage d&#39;une matrice en bytes</span>
<span class="co">// Ping !</span>

<span class="ot">#include &lt;msp430g2553.h&gt;</span>

<span class="ot">#define DELAI 100</span>

<span class="ot">#define SerClockSet P1OUT|=(1&lt;&lt;5)</span>
<span class="ot">#define SerClockClear P1OUT&amp;=~(1&lt;&lt;5)</span>

<span class="ot">#define ParClockSet P1OUT|=(1&lt;&lt;4)</span>
<span class="ot">#define ParClockClear P1OUT&amp;=~(1&lt;&lt;4)</span>

<span class="dt">void</span> AttenteMs (<span class="dt">uint16_t</span> duree) {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> i=<span class="dv">0</span>; i&lt;duree; i++) {
    <span class="kw">for</span> (<span class="dt">volatile</span> <span class="dt">uint16_t</span> j=<span class="dv">0</span>; j&lt;<span class="dv">500</span>; j++) {
    }
  }
}

<span class="ot">#define NbColonnes 16</span>
<span class="dt">uint8_t</span> Matrice[NbColonnes]; <span class="co">// mots de 8 bits, correspondant à une colonne</span>

<span class="ot">#define MaxX NbColonnes</span>
<span class="ot">#define MaxY 8</span>

<span class="dt">void</span> AllumePoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[x] |= (<span class="dv">1</span>&lt;&lt;y); <span class="co">// set bit</span>
}

<span class="dt">void</span> EteintPoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[x] &amp;=~(<span class="dv">1</span>&lt;&lt;y); <span class="co">// clear bit</span>
}

<span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    P2OUT = ~Matrice[x];
    SerClockSet; SerClockClear; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockSet; ParClockClear; <span class="co">// envoie les valeurs sur les LED</span>
}

<span class="dt">void</span> Ping() {
  <span class="dt">int16_t</span> x=<span class="dv">0</span>;
  <span class="dt">int16_t</span> y=<span class="dv">0</span>;
  <span class="dt">int8_t</span> sensX=<span class="dv">1</span>;
  <span class="dt">int8_t</span> sensY=<span class="dv">1</span>;
  <span class="kw">do</span> {
    AllumePoint(x,y);
    AfficheMatrice();
    AttenteMs(DELAI);
    EteintPoint(x,y);
    x+=sensX;
    <span class="kw">if</span>(x==(MaxX<span class="dv">-1</span>)) sensX=(-<span class="dv">1</span>);
    <span class="kw">if</span>(x==<span class="dv">0</span>) sensX=<span class="dv">1</span>;
    y+=sensY;
    <span class="kw">if</span>(y==(MaxY<span class="dv">-1</span>)) sensY=(-<span class="dv">1</span>);
    <span class="kw">if</span>(y==<span class="dv">0</span>) sensY=<span class="dv">1</span>;
  } <span class="kw">while</span> (!((x==<span class="dv">0</span>)&amp;&amp;(y==<span class="dv">0</span>)));
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
  WDTCTL = WDTPW + WDTHOLD; <span class="co">// Stop watchdog timer</span>
  BCSCTL1 = CALBC1_16MHZ; DCOCTL = CALDCO_16MHZ; <span class="co">// Horloge à 16 MHz</span>
  P1DIR = (<span class="dv">1</span>&lt;&lt;<span class="dv">4</span>)|(<span class="dv">1</span>&lt;&lt;<span class="dv">5</span>); P2DIR = <span class="bn">0xFF</span>; P2SEL = <span class="dv">0</span>;

  <span class="kw">for</span> (<span class="dt">uint16_t</span> i=<span class="dv">0</span>; i&lt;NbColonnes; i++) { <span class="co">// initialise la matrice</span>
    Matrice[i]=<span class="bn">0x0</span>;
  }

  <span class="kw">while</span>(<span class="dv">1</span>) {
    Ping();
  }
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
</body>
</html>
