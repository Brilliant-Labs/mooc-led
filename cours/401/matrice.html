<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Pierre-Yves Rochat, EPFL" />
  <title>Afficheurs matriciels</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../../statiques/style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Afficheurs matriciels</h1>
<h2 class="author"><script type="text/javascript">
<!--
h='&#112;&#x79;&#114;&#46;&#x63;&#104;';a='&#64;';n='&#112;&#x79;&#114;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+'Pierre-Yves Rochat'+'<\/'+'a'+'>');
// -->
</script><noscript>&#80;&#x69;&#x65;&#114;&#114;&#x65;&#x2d;&#x59;&#118;&#x65;&#x73;&#32;&#82;&#x6f;&#x63;&#104;&#x61;&#116;&#32;&#40;&#112;&#x79;&#114;&#32;&#x61;&#116;&#32;&#112;&#x79;&#114;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#104;&#x29;</noscript>, EPFL</h2>
<h3 class="date">rév 2015/09/16</h3>
</div>
<h2 id="afficheurs-et-écrans">Afficheurs et écrans</h2>
<p>Voici une définition du mot afficheur : dispositif électronique permettant de présenter visuellement des données. Cette définition correspond aussi très bien à ce qu'on appelle un écran. Ce terme écran vient de la technique des tubes cathodiques, qui comportaient un <em>écran</em> de phosphore, capable de transformer le faisceau d'électrons en une tache lumineuse.</p>
<p>Depuis plusieurs décennies, les LCD (Liquid Cristal Display) dominent ce domaine, tant pour de petits afficheurs que pour des écrans de taille respectable. On parle parfois par abus de langage d'écrans à LED pour désigner des écrans LCD rétro-éclairés par des LED. Il ne faut pas les confondre avec les écrans à O-LED (LED organiques), qui commencent à prendre une part du marché de plus en plus importante.</p>
<p>Ces domaines ne sont pas le sujet de notre cours. Nous allons nous concentrer sur les dispositifs réalisés avec des LED indépendantes.</p>
<h2 id="notion-de-pixel">Notion de pixel</h2>
<p>Chaque point d'un afficheur ou d'un écran est appelé un <em>pixel</em>. Il peut être d'une seule couleur (monochrome) ou capable de prendre plusieurs couleurs.</p>
<p>Un afficheur peut être caractérisé par plusieurs paramètres, qui nous embrouillent parfois. Celui qui, à mon sens, est le plus important, est le nombre de pixels. On donne souvent le nombre de ligne et le nombre de points par lignes.</p>
<p>Dans le domaine des écrans, les écrans VGA des années 1980 avaient déjà 480 lignes de 640 points. Aujourd'hui, l'écran d'un ordinateur portable à faible coût a déjà 800 lignes de 1'280 pixels. Une image vidéo <em>Full HD</em> a 1'080 lignes de 1'920 pixels.</p>
<p>La taille de l'afficheur est évidemment aussi un paramètre important, sa <em>hauteur</em> (on part de l'idée que l'écran est vertical) et sa largeur.</p>
<p>A partir de la taille et du nombre de pixels, on peut tirer deux autres caractéristiques d'un afficheur :</p>
<ul>
<li>Sa résolution. C'est la distance entre un pixel et son plus proche voisin. On l'exprime généralement en mm. Les fabricants donnent souvent une expression comme P6 ou P10. La lettre P vient du mot <em>Pitch</em> (le pas). Il s'agit bien de la distance entre chaque pixels, en mm.</li>
<li>Sa densité. C'est le nombre de pixels par unité de surface. L'unité est généralement exprimée en pixels par mètres carrés.</li>
</ul>
<p>Prenons l'exemple d'un afficheur P6. La distance entre chaque pixel est de 6mm. On peut donc aligner environ 167 LED sur un mètre. Il faut donc plus de 27'800 LED pour remplir un mètre carré !</p>
<h2 id="afficheurs-à-led">Afficheurs à LED</h2>
<p>Un afficheur à LED est donc un ensemble de LED dont il est possible de choisir l'état de chacune indépendamment des autres.</p>
<p>Les LED sont généralement disposées en ligne et en colonne : on obtient un afficheur orthogonal.</p>
<div class="figure">
<img src="images/aff-10x24-120dpi.png" title="Afficheur de 10x24 LED" alt="Afficheur de 10x24 LED" />
<p class="caption">Afficheur de 10x24 LED</p>
</div>
<p>Si la distance est la même horizontalement et verticalement (en x et y), l'afficheur est orthonormé. La nature des LED permet de réaliser toute sorte d'afficheurs, sans se limiter à une grille orthonormée. On peut par exemple imaginer des afficheurs cylindriques, sphériques ou en forme de pyramide ! Plus couramment, on trouve des afficheurs qui prennent une forme dont la signification est connue, comme par exemple les afficheurs en forme de croix de pharmacie, très répandus depuis quelques années.</p>
<p>La taille des afficheurs à LED varie de manière considérable : on trouve de petits journaux lumineux sur certains médaillons de ceinture, mais il existe aussi des afficheurs vidéos d'une surface de plusieurs dizaines de mètres carrés.</p>
<h2 id="commande-des-led-par-des-registres">Commande des LED par des registres</h2>
<p>Il est clair que le nombre de LED d'un afficheur matriciel, même de petite taille, ne permet généralement pas une commande de chaque LED par une broche d'un microcontrôleur. C'est seulement le cas pour de petits afficheurs commandés par <em>multiplexage temporel</em>, sujet qui sera abordé plus tard. Dans tous les autres cas, des registres sont utilisés pour commander les LED.</p>
<p>Prenons comme exemple un afficheur de 8 lignes de 16 LED. Il va utiliser un registre série-parallèle de 16 bits pour chaque ligne, soit 8 registres. Tout naturellement, les entrées séries de chaque registre vont être connectées à des broches du microcontrôleur. Les horloges série et parallèles peuvent être connectées ensemble : les données vont être injectées dans les registres série en même temps et c'est aussi en même temps que les valeurs décalées vont être envoyées sur les LED par le registre parallèle. Voici donc le schéma :</p>
<div class="figure">
<img src="images/aff-8x16-120dpi.png" title="Schéma d&#39;un afficheur comportant 8 lignes de 16 LED" alt="Schéma d&#39;un afficheur comportant 8 lignes de 16 LED" />
<p class="caption">Schéma d'un afficheur comportant 8 lignes de 16 LED</p>
</div>
<p>Remarquez que les LED n'ont pas de résistances série. Les registres utilisés contiennent des sources de courants, ajustables par une seule résistance pour tout le registre.</p>
<h2 id="programmation">Programmation</h2>
<p>Comment écrire le programme qui contrôle ce montage ? On souhaite par exemple faire défiler un texte, pour faire un journal lumineux. La première idée qui vient à l'esprit est d'utiliser les propriétés du registre pour introduire successivement les colonnes de pixels qui forment chaque caractères . Voici un programme qui pourrait fonctionner. Il se limite pour le moment d'envoyer un motif en <em>dent de scie</em> :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">int</span> main() {
  <span class="co">// initialisations...</span>
  <span class="dt">uint8_t</span> i;
  <span class="kw">while</span> (<span class="dv">1</span>) {
    <span class="kw">for</span> (i=0; i&lt;16; i++) { <span class="co">// envoie une colonne avec un seul pixel allumé</span>
      P1OUT = (1&lt;&lt;(i&amp;7)); <span class="co">// une colonne de 8 pixels, un seul allumé</span>
      SerClockOn; SerClockOff; <span class="co">// envoie un coup d&#39;horloge série</span>
      ParCloclOn; ParClockOff; <span class="co">// envoie un coup d&#39;horloge</span>
    }
  }
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Pour gérer des caractères, il faut disposer d'une table décrivant les pixels des différents caractères. Voici une manière de les représenter :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">const</span> <span class="dt">uint8_t</span> GenCar [] { <span class="co">// tableau des pixels des caractères</span>
  0b01111110, <span class="co">// caractère &#39;A&#39;</span>
  0b00001001, <span class="co">// Il faut pencher la tête à droite</span>
  <span class="bn">0b00001001</span>, <span class="co">// pour voire sa forme !</span>
  <span class="bn">0b00001001</span>,
  <span class="bn">0b01111110</span>,

  0b01111111, <span class="co">// caractère &#39;B&#39;</span>
  0b01001001, <span class="co">// Les caractères forment une</span>
  <span class="bn">0b01001001</span>, <span class="co">// une matrice de 5x7</span>
  <span class="bn">0b01001001</span>,
  <span class="bn">0b00110110</span>,

  0b00111110, <span class="co">// caractère &#39;C&#39;</span>
  0b01000001, <span class="co">// Les caractères ont ici</span>
  <span class="bn">0b01000001</span>, <span class="co">// une &quot;chasse&quot; fixe</span>
  0b01000001, <span class="co">// (un même nombre de pixel</span>
  0b01000001  <span class="co">// quelque soit le caractère)</span>
};</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Voici un programme qui affiche un texte :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">char</span> *Texte = <span class="st">&quot;ABC\0&quot;</span>; <span class="co">// texte, terminé par le caractère nul</span>
<span class="dt">const</span> <span class="dt">char</span> *ptTexte; <span class="co">// pointeur au texte à afficher</span>

<span class="dt">int</span> main(<span class="dt">void</span>) {
  ... initialisations

  <span class="kw">while</span>(1) { <span class="co">// le texte défile sans fin</span>
    ptTexte = Texte;
    <span class="kw">while</span> (*ptTexte!=&#39;\0&#39;) { <span class="co">// boucle des caractères du texte</span>
      caractere = *ptTexte; <span class="co">// le caractère à afficher</span>
      idxGenCar = (caractere-&#39;A&#39;) * 5; <span class="co">// index dans le générateur</span>
      <span class="kw">for</span> (i=0; i&lt;5; i++) { <span class="co">// envoie les 5 colonnes du caractère</span>
        P2OUT = ~GenCar[idxGenCar++]; <span class="co">// une colonne du caractère (actif à 0)</span>
        SerClockOn; SerClockOff; <span class="co">// coup d&#39;horloge série</span>
        ParClockOn; ParClockOff; <span class="co">// coup d&#39;horloge parallèle</span>
        AttenteMs (delai);
      }
      ptTexte++; <span class="co">// passe au caractère suivant</span>
      P2OUT = ~0; <span class="co">// colonne vide, séparant les caractères</span>
      SerClockOn; SerClockOff; <span class="co">// coup d&#39;horloge série</span>
      ParClockOn; ParClockOff; <span class="co">// coup d&#39;horloge parallèle</span>
      AttenteMs (delai);
    }
  }
}

    </code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Pour cet exemple simple, le texte à afficher a été placé comme un tableau. Le mot <code>const</code> indique au compilateur qu'il peut être placé directement en mémoire de programme. Pour accéder aux caractère de ce texte, un pointeur est utilisé. La déclaration du pointeur s'écrit : <code>const char *ptTexte;</code>. Le symbole * indique qu'il s'agit d'un pointeur.</p>
<p>Cette manière d'envoyer les caractères fonctionne, mais présente tellement de limitations qu'elle ne sera jamais utilisée. Par exemple, elle ne peut pas fonctionner si l'ordre des LED est inversé : le texte ne pourra pas se décaler correctement de droite à gauche. Elle est aussi incompatible avec les afficheurs multiplexés.</p>
<h2 id="génération-et-rafraîchissement-séparés">Génération et rafraîchissement séparés</h2>
<p>La bonne manière de programmer un afficheur est de <strong>séparer</strong> complètement la génération de l'image à afficher et l'envoi de cette image sur l'afficheur. La valeur courante de chaque pixel sera placée dans une <strong>mémoire</strong>. La partie du logiciel qui prépare les images va <strong>écrire</strong> dans cette mémoire. Les procédures qui vont envoyer les informations à l'afficheur vont <strong>lire</strong> dans cette mémoire.</p>
<p>Dans notre exemple, l'afficheur a 8 lignes de 16 pixels. Un mot de 16 bit pourra donc mémoriser une ligne. Voici comment réserver la zone mémoire pour les pixels :</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define NbLignes 8</span>
<span class="dt">uint16_t</span> Matrice[NbLignes]; <span class="co">// mots de 16 bits, correspondant à une ligne</span></code></pre>
<!-- retour au mode normal pour l'éditeur -->
<p>Nous choissons de placer les axes x et y de la manière suivante :</p>
<div class="figure">
<img src="images/organisation-aff-8x16-120dpi.png" title="Organisation de l&#39;afficheur 8x16 pixels" alt="Organisation de l&#39;afficheur 8x16 pixels" />
<p class="caption">Organisation de l'afficheur 8x16 pixels</p>
</div>
<p>Les procédures permettant d'allumer et d'éteindre un pixel, désigné par ses coordonnées, sont particulièrement simples dans ce cas :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">void</span> AllumePoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[y] |= (<span class="dv">1</span>&lt;&lt;x); <span class="co">// set bit</span>
}

<span class="dt">void</span> EteintPoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[y] &amp;=~(<span class="dv">1</span>&lt;&lt;x); <span class="co">// clear bit</span>
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Voici une procédure pour afficher une diagonale en travers de l'afficheur :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#define MaxX 16</span>
<span class="ot">#define MaxY NbLignes</span>

<span class="dt">void</span> Diagonale() {
  <span class="dt">int16_t</span> i;
  <span class="kw">for</span> (i=<span class="dv">0</span>; i&lt;MaxY; i++) {
    AllumePoint(i*MaxX/MaxY, i);
  }
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Mais toutes ces procédures ne vont rien afficher sur les LED ! Il faut encore une procédure qui va placer chaque pixel sur la LED correspondante. Pour l'écrire, il faut garder en mémoire l'organisation matérielle de notre matrice, avec les 8 registres série-parallèles de 16 bits.</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    <span class="co">// Préparation des valeurs qui doivent être envoyées aux 8 registres:</span>
    <span class="kw">for</span> (<span class="dt">uint16_t</span> y=<span class="dv">0</span>; y&lt;MaxY; y++)  { 
      <span class="kw">if</span> (Matrice[y]&amp;(<span class="dv">1</span>&lt;&lt;x)) P2OUT &amp;=~(<span class="dv">1</span>&lt;&lt;y); <span class="kw">else</span> P2OUT |= (<span class="dv">1</span>&lt;&lt;y);
    }
    SerClockOn; SerClockOff; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockOn; ParClockOff; <span class="co">// envoie les valeur sur les LED</span>
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Cette procédure semble compliquée. Une autre organisation des données en mémoire pourrait conduire une procédure beaucoup plus simple :</p>
<div class="figure">
<img src="images/organisation-aff-8x16-byte-120dpi.png" title="Organisation plus optimale des pixels en mémoire" alt="Organisation plus optimale des pixels en mémoire" />
<p class="caption">Organisation plus optimale des pixels en mémoire</p>
</div>
<p>Voici la définition et le procédure correspondante :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#define NbColonnes 16</span>
<span class="dt">uint8_t</span> Matrice[NbColonnes]; <span class="co">// mots de 8 bits, correspondant à une colonne</span>

<span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    P2OUT = ~Matrice[x];
    SerClockOn; SerClockOff; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockOn; ParClockOff; <span class="co">// envoie les valeur sur les LED</span>
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
<p>Non seulement la procédure <code>AfficheMatrice()</code> est beaucoup plus simple, mais en plus elle va prendre moins de temps pour son exécution. Dans notre cas, la vitesse ne pose pas de problème. Mais dès que les afficheurs deviennent plus grands, cette question devient cruciale.</p>
<p>De manière générale, on va donc chercher à optimiser l'organisation des pixels en mémoire en vue de simplifier et de rendre plus rapide l'envoi des pixels sur les LED, quitte à compliquer un peu les procédures qui créent les images.</p>
<h2 id="programmer-des-animations">Programmer des animations</h2>
<p>Pour générer des animations sur l'afficheur, il faut :</p>
<ul>
<li>préparer une image en mémoire,</li>
<li>envoyer son contenu sur l'afficheur,</li>
<li>attendre le temps voulu,</li>
<li>préparer une autre image</li>
</ul>
<p>et ainsi de suite.</p>
<p>Voici un programme complet qui génère une animation graphique sur notre afficheur :</p>
<table class="sourceCode c numberLines" startFrom="1"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="co">// Afficheur didactique 16x8</span>
<span class="co">// Les 8 bits sont sur P2</span>
<span class="co">// Usage d&#39;une matrice en byte</span>
<span class="co">// Ping !</span>

<span class="ot">#include &lt;msp430g2553.h&gt;</span>

<span class="ot">#define DELAI 100</span>

<span class="ot">#define SerClockOn P1OUT|=(1&lt;&lt;5)</span>
<span class="ot">#define SerClockOff P1OUT&amp;=~(1&lt;&lt;5)</span>

<span class="ot">#define ParClockOn P1OUT|=(1&lt;&lt;4)</span>
<span class="ot">#define ParClockOff P1OUT&amp;=~(1&lt;&lt;4)</span>

<span class="dt">void</span> AttenteMs (<span class="dt">uint16_t</span> duree) {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> i=<span class="dv">0</span>; i&lt;duree; i++) {
    <span class="kw">for</span> (<span class="dt">volatile</span> <span class="dt">uint16_t</span> j=<span class="dv">0</span>; j&lt;<span class="dv">500</span>; j++) {
    }
  }
}

<span class="ot">#define NbColonnes 16</span>
<span class="dt">uint8_t</span> Matrice[NbColonnes]; <span class="co">// mots de 8 bits, correspondant à une colonne</span>

<span class="ot">#define MaxX NbColonnes</span>
<span class="ot">#define MaxY 8</span>

<span class="dt">void</span> AllumePoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[x] |= (<span class="dv">1</span>&lt;&lt;y); <span class="co">// set bit</span>
}

<span class="dt">void</span> EteintPoint(<span class="dt">int16_t</span> x, <span class="dt">int16_t</span> y) {
  Matrice[x] &amp;=~(<span class="dv">1</span>&lt;&lt;y); <span class="co">// clear bit</span>
}

<span class="dt">void</span> AfficheMatrice() {
  <span class="kw">for</span> (<span class="dt">uint16_t</span> x=<span class="dv">0</span>; x&lt;MaxX; x++) {
    P2OUT = ~Matrice[x];
    SerClockOn; SerClockOff; <span class="co">// envoie un coup d&#39;horloge série</span>
  }
  ParClockOn; ParClockOff; <span class="co">// envoie les valeur sur les LED</span>
}

<span class="dt">void</span> Ping() {
  <span class="dt">int16_t</span> x=<span class="dv">0</span>;
  <span class="dt">int16_t</span> y=<span class="dv">0</span>;
  <span class="dt">int8_t</span> sensX=<span class="dv">1</span>;
  <span class="dt">int8_t</span> sensY=<span class="dv">1</span>;
  <span class="kw">do</span> {
    AllumePoint(x,y);
    AfficheMatrice();
    AttenteMs(DELAI);
    EteintPoint(x,y);
    x+=sensX;
    <span class="kw">if</span>(x==(MaxX<span class="dv">-1</span>)) sensX=(-<span class="dv">1</span>);
    <span class="kw">if</span>(x==<span class="dv">0</span>) sensX=<span class="dv">1</span>;
    y+=sensY;
    <span class="kw">if</span>(y==(MaxY<span class="dv">-1</span>)) sensY=(-<span class="dv">1</span>);
    <span class="kw">if</span>(y==<span class="dv">0</span>) sensY=<span class="dv">1</span>;
  } <span class="kw">while</span> (!((x==<span class="dv">0</span>)&amp;&amp;(y==<span class="dv">0</span>)));
}

<span class="dt">int</span> main(<span class="dt">void</span>) {
  WDTCTL = WDTPW + WDTHOLD; <span class="co">// Stop watchdog timer</span>
  BCSCTL1 = CALBC1_16MHZ; DCOCTL = CALDCO_16MHZ; <span class="co">// Horloge à 16 MHz</span>
  P1DIR = (<span class="dv">1</span>&lt;&lt;<span class="dv">4</span>)|(<span class="dv">1</span>&lt;&lt;<span class="dv">5</span>); P2DIR = <span class="bn">0xFF</span>; P2SEL = <span class="dv">0</span>;

  <span class="kw">for</span> (<span class="dt">uint16_t</span> i=<span class="dv">0</span>; i&lt;NbColonnes; i++) { <span class="co">// initialise la matrice</span>
    Matrice[i]=<span class="bn">0x0</span>; 
  }
  
  <span class="kw">while</span>(<span class="dv">1</span>) { 
    Ping();
  }
}</code></pre></td></tr></table>
<!-- retour au mode normal pour l'éditeur -->
</body>
</html>
