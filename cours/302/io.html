<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="nico" />
  <meta name="author" content="Pierre-Yves Rochat, EPFL" />
  <title>Entrées-sorties</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../statiques/style.css" type="text/css" />
</head>
<body>
<h1 class="title">Entrées-sorties</h1>
<div id="header">
<p class="author"><a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#112;&#x79;&#114;&#64;&#112;&#x79;&#114;&#46;&#x63;&#104;" class="email">&#80;&#x69;&#x65;&#114;&#114;&#x65;&#x2d;&#x59;&#118;&#x65;&#x73;&#32;&#82;&#x6f;&#x63;&#104;&#x61;&#116;</a>, EPFL</p>
<p class="date">rév 2016/02/08</p>
</div>
<h2 id="ports-des-microcontrôleurs">Ports des microcontrôleurs</h2>
<p>Dans les microcontrôleurs se trouvent des pattes groupées par 8 bit (parfois par 16 ou 32 bits). On les appelle des Ports. Les ports ont des noms, par exemple :</p>
<ul>
<li>PORTA, PORTB, PORTC, pour les AVR ou les PIC</li>
<li>P1, P2, pour les MSP430.</li>
</ul>
<p>Chaque patte a aussi un nom, dérivé du nom du port :</p>
<ul>
<li>PA0, PA1, PA2, pour les AVR</li>
<li>P1.0, P1.1, P1.2, pour les MSP430</li>
</ul>
<p>Des registres spécialisés permettent de manipuler les ports, par exemple :</p>
<ul>
<li>PORTA, PINA, DDRA pour les AVR</li>
<li>PORTA, PORTA, TRISA pour les PIC</li>
<li>P1OUT, P1IN, P1DIR pour le MSP430</li>
</ul>
<p>Voici le schéma simplifié correspondant à chaque patte d’entrée-sortie, illustré ici pour la patte P1.0 d’un MSP430G.</p>
<div class="figure">
<img src="images/transistor-serie-led-40dpi.png" title="Utilisation de plusieurs LED en série" alt="Figure : Utilisation de plusieurs LED en série" width="264" />
<p class="caption">Figure : Utilisation de plusieurs LED en série</p>
</div>
<p>On y trouve deux passeurs. L’un permet à tout instant de lire l’état de la patte. L’autre permet d’imposer une valeur logique à la patte, lorsqu’il s’agit d’une sortie. On y trouve aussi deux bascules. Chacune fait partie d’un registre 8 bit. L’une de ces bascules est appelée PxDIR ( Port Direction ). Elle permet d’activer ou non la sortie. L’autre est appelée PxOUT (Port Output). Elle donne l’état devant être passé à la sortie.</p>
<p>Ce schéma est très pratique. Il permet en effet de choisir le rôle de chaque patte d’entrée-sortie et de ceci à tout instant. Certains dispositifs de communication nécessitent en effet qu’un patte soit une entrée à certains moments et une sortie à d’autres. C’est le cas par exemple de l’interface de claviers PS-2 des PC. Le tableau suivant donne la fonctionnalité correspondant à l’état des deux bascules, pour un des bits du port (ici le bit 6).</p>
<p>Voici donc un exemple d’initialisation des ports, pour avoir P1.0 et P0.6 en sortie et P1.3 en entrée : P1DIR = 0b01000001; Le pattes non utilisées sont laissées en entrée. En écrivant : P1OUT = 1; on va passer la sortie P10. À l’état haut. Mais on va aussi mettre la sortie P1.6 à zéro !</p>
<p>Manipulation de champs de bits On sent le besoin de pouvoir agir de manière séparée sur chaque bit à l’intérieur d’un registre. Le document « Manipulation de champs de bits » présente ce sujet en détail. Pour le résumer : Set-bit (mettre un bit à 1). Exemple : P1OUT |= (1&lt;&lt;6); Clear-bit (mettre un bit à 0). Exemple : P1OUT &amp;=~(1&lt;&lt;6); Test-bit (tester la valeur d’un bit). Exemple : if (P1IN &amp; (1&lt;&lt;3)) ...</p>
<p>2009-2013, Pierre-Yves Rochat, pyr@pyr.ch version du 2013/11/10 ## Champs de bits ##</p>
<p>Les ports d’entrée-sortie des microcontrôleurs sont le plus souvent vus par l’application comme des bits séparés, alors qu’ils sont physiquement adressés par groupe de 8 bits. Il faut donc disposer des outils nécessaires pour manipuler séparément des bits à l’intérieur d’un champs de bits (bit set).</p>
<p>Trois problèmes se posent :</p>
<ul>
<li>mettre un ou plusieurs bits à la valeur 1 (set bit)</li>
<li>mettre un ou plusieurs bits à la valeur 0 (clear bit)</li>
<li>tester la valeur d’un bit (test bit).</li>
</ul>
<p>Prenons un exemple concret : les différents bits de P1OUT (port d’entrée sortie 1) d’un MSP430 sont utilisés à diverses fins, certains comme entrées, d’autres comme sorties. Sur la broche P1.6 se trouve une LED, qu’on souhaite allumer ou éteindre à certains moments. Sur les broches P1.2 et P1.3 se trouvent des boutons-poussoirs.</p>
<h2 id="set-bit">Set bit</h2>
<p>Pour mettre un bit à la valeur 1, le problème se pose de la manière suivante: P1OUT contient les valeurs: x7 x6 x5 x4 x3 x2 x1 x0, toutes inconnues à priori. Après l’opération Set Bit sur le bit P1.6, on souhaite obtenir les valeurs suivantes: x7 1 x5 x4 x3 x2 x1 x0 dans P1OUT. Les lois de l’algèbre de Boole nous affirment les égalités suivantes: A . 0 = 0 A . 1 = A (1 est l’élément neutre du ET) A + 0 = A (0 est l’élément neutre du OU) A + 1 = 1 On remarque rapidement que l’opération OU logique va nous permettre de réaliser la mise à 1 d’un bit : P1OUT x7 x6 x5 x4 x3 x2 x1 x0 Second opérande 0 1 0 0 0 0 0 0 ------------------------------ OU Résultat x7 1 x5 x4 x3 x2 x1 x0 L’opérateur OU s’appliquant à un champ de bits s’écrit | en C. Il ne faut pas le confondre avec l’opérateur || qui s’applique à deux valeurs vues comme des booléans (la valeur 0 correspondant à faux et toute valeur différente de zéro correspondant à vrai). L’opération Set Bit s’écrit donc, dans notre exemple: P1OUT = P1OUT | 0x40; La syntaxe suivante est équivalente, mais plus compacte à écrire : P1OUT|= 0x40; Noter les valeurs directement en hexa-décimal, ou encore en décimal, rend les programmes peu lisibles. On préfèrera la syntaxe suivante:</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode c">P1OUT|= (<span class="dv">1</span>&lt;&lt;<span class="dv">6</span>); <span class="co">// ou P1OUT|= BIT6;</span></code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
<p>La constante BIT6 vaut <code>(1&lt;&lt;6)</code> dans les déclarations standard proposées pour les MSP430. C’est le rang du bit dans l’octet, ou autrement dit la puissance de 2 correspondante. L’opérateur de décalage est utilisé ici pour mettre le bit à sa place. Remarque importante: l’expression <code>(1&lt;&lt;6)</code> est évaluée à la compilation et non à l’exécution, vu qu’elle ne comporte que des constantes. Choisir d’écrire de manière lisible ne pénalise donc pas les performances du programme, ni la taille du binaire ! Clear bit De la même manière, on utilisera l’opération logique ET pour la mise à 0 d’un bit. Mais l’élément neutre est alors le 1 :</p>
<p><code>P1OUT  x7  x6  x5  x4  x3  x2  x1  x0</code> <code>Second opérande    1   0   1   1   1   1   1   1</code> <code>------------------------------  ET</code> <code>Résultat   x7  0   x5  x4  x3  x2  x1  x0</code></p>
<p>D’où l’expression: <code>P1OUT = P1OUT &amp; 0xBF;</code></p>
<p>On préfèrera la notation suivante : <code>P1OUT &amp;=~(1&lt;&lt;6); // ou P1OUT &amp;=~(BIT6);</code></p>
<p>Rappel : l’opérateur ~ effectue une inversion bit-à-bit sur un champ de bits.</p>
<h2 id="test-bit">Test bit</h2>
<p>L’utilisation d’un bouton-poussoir doit permettre d’effectuer un débranchement dans le cours du programme: si le bouton est pressé, alors telle action doit être réalisée. C’est la structure <code>if (condition) ...</code> du C.</p>
<p>Une condition est simplement représentée par un nombre: la condition est fausse si le nombre vaut 0, et vraie dans le cas contraire.</p>
<p>La lecture des valeurs se trouvant sur les broches de P1.0 à P1.7 se fait en lisant la valeur de <code>P1IN</code>. On cherche une opération logique dont le résultat sera 0 si le bit testé vaut 0 (condition fausse), alors que il sera non-nul si le bit testé vaut 1 (condition vraie). C’est la fonction ET qui va être utilisée:</p>
<p><code>P1IN   x7   x6   x5   x4   x3   x2   x1   x0</code> <code>Second opérande    0    0    0    0    0    1    0    0</code> <code>--------------------------------------  ET</code> <code>Résultat   0    0    0    0    0    x2   0    0</code></p>
<p>En C, on écrit : <code>if ( P1IN &amp; (1&lt;&lt;2) )... // ou if ( P1IN &amp; (BIT2) )</code></p>
<p>La valeur binaire contenant le bit qu’on souhaite tester s’appelle un masque. En effet, l’opération ET entre un champ de bits et cette valeur permet de maquer les bits qui ne nous intéressent pas, afin de ne garder que le bit, ou les bits, à tester.</p>
<h2 id="exemple">Exemple</h2>
<p>Une pression sur les boutons-poussoirs ON et OFF doivent respectivement allumer et éteindre la LED. Le schéma n’indique que les ajouts par rapport au schéma de base, qui contient aussi les alimentation et les signaux de programmation.</p>
<p>Voici le programme correspondant :</p>
<div class="sourceCode" startFrom="1"><table class="sourceCode c numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode c"><span class="ot">#include &lt;MSP430G2553.h&gt;</span>
<span class="dt">int</span> main() {
    WDTCTL = WDTPW + WDTHOLD;
    P1DIR|= (<span class="dv">1</span>&lt;&lt;<span class="dv">6</span>); <span class="co">// LED en sortie</span>
    P1OUT|= (<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>) | (<span class="dv">1</span>&lt;&lt;<span class="dv">3</span>); <span class="co">// résistances en pull-up</span>
    P1REN|= (<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>)|(<span class="dv">1</span>&lt;&lt;<span class="dv">3</span>); <span class="co">// connexion des résistances sur les entrées</span>
    <span class="kw">while</span> (<span class="dv">1</span>) { <span class="co">// boucle infinie</span>
      <span class="kw">if</span> (!(P1IN &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">2</span>)) P1OUT |= (<span class="dv">1</span>&lt;&lt;<span class="dv">6</span>); <span class="co">// bouton ON</span>
      <span class="kw">if</span> (!(P1IN &amp; (<span class="dv">1</span>&lt;&lt;<span class="dv">3</span>)) P1OUT &amp;= ~(<span class="dv">1</span>&lt;&lt;<span class="dv">6</span>); <span class="co">// bouton OFF</span>
    }
}</code></pre></td></tr></table></div>
<!-- retour au mode normal pour l'éditeur -->
</body>
</html>